# Конструктор, створення об’єктів через "new"

Регулярний синтаксис {...} дозволяє створити один об’єкт. Але часто нам потрібно створити багато подібних об'єктів, як, наприклад, декілька користувачів або пункти меню тощо.

Это можно сделать при помощи функции-конструктора и оператора `"new"`.

## Функція конструктора

Функції конструктора технічно є звичайними функціями. Однак існують дві конвенції:

1.  Ім’я повинно починатися з великої літери.
2.  Вони повинні виконуватися лише з "new" оператором.


Наприклад:

```js run
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

*!*
let user = new User("Jack");
*/!*

alert(user.name); // Jack
alert(user.isAdmin); // false
```

Коли функція виконується за допомогою new, вона виконує такі кроки:

1. Створюється і присвоюється новий порожній об’єкт this.
2. Виконується код функції.  Зазвичай він модифікується this, додає до нього нові властивості.
3. Значення this повертається. 

Іншими словами, new User(...) робить щось на кшталт: 

```js
function User(name) {
*!*
  // this = {};  (неявно)
*/!*

  // додає властивості до this
  this.name = name;
  this.isAdmin = false;

*!*
  // return this;  (неявно)
*/!*
}
```

Тому результат виклика let user = new User("Jack") такий самий як:

```js
let user = {
  name: "Jack",
  isAdmin: false
};
```

Тепер , якщо ми хочемо створити інших користувачів, ми можемо назвати new User("Ann"), new User("Alice")і так далі. Набагато коротше, ніж кожен раз використовувати літерали, а також легко читати.  

Ось головна мета конструкторів - реалізувати код створення об'єктів багаторазового використання.

Відзначимо ще раз - технічно будь-яка функція може бути використана як конструктор. Тобто: будь-яку функцію можна запустити new, і вона виконає алгоритм вище. "Перша велика літера" - це спільна угода, щоб зрозуміти, що функцію слід виконувати new.


````smart header="new function() { ... }"
Якщо в нашому коді велику кількість рядків, що створюють один складний об'єкт, ми можемо обернути їх в функцію-конструктор в такий спосіб:

```js
let user = new function() {
  this.name = "John";
  this.isAdmin = false;

  // ...інший код для створення користувача
  // можлива будь-яка складна логіка і вирази
  // локальні змінні і т. д.

};
```
Такий конструктор не може бути викликаний двічі, так як він ніде не зберігається, просто створюється і відразу ж викликається. Таким чином, такий метод створення дозволяє інкапсулювати код, який створює окремий об'єкт, але без можливості його повторного використання.
````

## Перевірка на виклик в режимі конструктора : new.target

```smart header="Продвинутая возможность"
Даний метод використовується дуже рідко. Ви можете пропустити цю секцію, якщо не хочете заглиблюватися в деталі мови.
```

Використовуючи спеціальне властивість `new.target` всередині функції, ми можемо перевірити, чи викликана функція за допомогою оператора` new` або без нього.

У разі, якщо функція викликана за допомогою `new`, то в` new.target` буде сама функція, в іншому випадку `undefined`.

```js run
function User() {
  alert(new.target);
}

// без "new":
*!*
User(); // undefined
*/!*

// с "new":
*!*
new User(); // function User { ... }
*/!*
```

Це можна використовувати, щоб відрізнити звичайний виклик від виклику "в режимі конструктора". Зокрема, ось так можна зробити, щоб функцію можна було викликати як з, так і без `new`:

```js run
function User(name) {
  if (!new.target) { // у випадку, якщо ви викликали без оператора"new":
    return new User(name); // ...додамо опертор new за вас
  }

  this.name = name;
}

let john = User("John"); // переадресовує виклик на new User
alert(john.name); // John
```

Такий підхід іноді використовується в бібліотеках для створення більш гнучкого синтаксису, який дозволяє розробникам викликати функції за допомогою оператора new або без нього.

Втім, це не дуже гарна практика, так як відсутність new може ввести розробника в оману. З оператором new ми точно знаємо, що в результаті буде створено новий об'єкт.



## Повернення  значення із конструктора return

Зазвичай конструктори нічого не повертають явно. Їх завдання - записати все необхідне в this, який в підсумку стане результатом.
Але якщо return все ж є, то застосовується просте правило:

-	Якщо return викликається об'єктом, то  повертається об'єкт ,а не this
-	Якщо return з примітивним значенням, примітивне значення буде відкинуто.

 Іншими словами, return з об'єктом повертає цей об'єкт, у всіх інших випадках повертається this.


У прикладі нижче return повертає об'єкт замість this:

```js run
function BigUser() {

  this.name = "John";

  return { name: "Godzilla" };  // <-- повертає цей об’єкт
}

alert( new BigUser().name );  // Godzilla, отримали цей об’єкт
```

Ось приклад із порожнім return(або ми можемо розмістити примітив після нього, не має значення):

```js run
function SmallUser() {

  this.name = "John";

  return; // <-- повертає this
}

alert( new SmallUser().name );  // Jack
```

Зазвичай у конструкторів відсутній return. В даному блоці ми згадали особливу поведінка з поверненням об'єктів, щоб не залишати пробілів у вивченні мови.


````smart header="Отсутствие скобок"
До речі, ми можемо не ставити дужки після `new`, якщо виклик конструктора йде без аргументів.

```js
let user = new User; // <-- без дужок
// то же, що і
let user = new User();
```

Пропуск дужок вважається поганою практикою, але синтаксис мови таке дозволяє.
````

## Створення методів у конструкторі

Використання функцій конструктора для створення об'єктів дає велику гнучкість. Функція конструктора може мати параметри, які визначають, як конструювати об’єкт і що в нього помістити.

Звичайно, ми можемо додати thisне лише властивості, але й методи.

Наприклад, new User(name)нижче створюється об'єкт із заданим name методом sayHi:

```js run
function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "Моє ім'я: " + this.name );
  };
}

*!*
let jack = new User("John");

jack.sayHi(); // Моє ім'я: John
*/!*

/*
jack = {
   name: "John",
   sayHi: function() { ... }
}
*/
```

Щоб створити складні об'єкти, є більш досконалий синтаксис, класи, які ми розберемо пізніше. 

## Підсумок

- Функції конструктора або, коротко кажучи, конструктори, є звичайними функціями, але існує спільна згода спочатку назвати їх з великої літери. 
- Функції конструктора слід викликати лише за допомогою new.  Такий дзвінок передбачає створення порожнього this на початку та повернення заповненого в кінці.


Ми можемо використовувати функції конструктора для створення декількох подібних об'єктів. 

JavaScript надає функції-конструктори для безлічі вбудованих об'єктів мови: наприклад, Date, Set і інших, які нам ще належить вивчити.

```smart header="Объекты, мы к ним ещё вернёмся!"
У цьому розділі ми розглянули базові принципи об'єктів і конструкторів. Дана інформація необхідна нам для подальшого вивчення типів даних і функцій. Як тільки ми з ними розберемося, ми повернемося до об'єктів для більш детального вивчення в главах <info: prototypes> і <info: classes>.
```
